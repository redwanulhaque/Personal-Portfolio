// Website Tabs
var content1 = document.getElementById("content1");
var content2 = document.getElementById("content2");
var content3 = document.getElementById("content3");
var content4 = document.getElementById("content4");
var content5 = document.getElementById("content5");
var content6 = document.getElementById("content6");
var content7 = document.getElementById("content7");

var btn1 = document.getElementById("btn1");
var btn2 = document.getElementById("btn2");
var btn3 = document.getElementById("btn3");
var btn4 = document.getElementById("btn4");
var btn5 = document.getElementById("btn5");
var btn6 = document.getElementById("btn6");
var btn7 = document.getElementById("btn7");

function open1(){
  content1.style.transform = "translateX(0)";
  content2.style.transform = "translateX(2500%)";
  content3.style.transform = "translateX(900%)";
  content4.style.transform = "translateX(900%)";
  content5.style.transform = "translateX(1500%)";
  content6.style.transform = "translateX(1500%)";
  content7.style.transform = "translateX(900%)";

  btn1.style.color = "#ff7846"
  btn2.style.color = "#ccc"
  btn3.style.color = "#ccc"
  btn4.style.color = "#ccc"
  btn5.style.color = "#ccc"
  btn6.style.color = "#ccc"
  btn7.style.color = "#ccc"

  content1.style.transitionDelay = "0.3s";
  content2.style.transitionDelay = "0s";
  content3.style.transitionDelay = "0s";
  content4.style.transitionDelay = "0s";
  content5.style.transitionDelay = "0s";
  content6.style.transitionDelay = "0s";
  content7.style.transitionDelay = "0s";
}

function open2(){
  content1.style.transform = "translateX(1500%)";
  content2.style.transform = "translateX(0)";
  content3.style.transform = "translateX(900%)";
  content4.style.transform = "translateX(900%)";
  content5.style.transform = "translateX(1500%)";
  content6.style.transform = "translateX(1500%)";
  content7.style.transform = "translateX(900%)";

  btn2.style.color = "#ff7846"
  btn1.style.color = "#ccc"
  btn3.style.color = "#ccc"
  btn4.style.color = "#ccc"
  btn5.style.color = "#ccc"
  btn6.style.color = "#ccc"
  btn7.style.color = "#ccc"

  content2.style.transitionDelay = "0.3s";
  content1.style.transitionDelay = "0s";
  content3.style.transitionDelay = "0s";
  content4.style.transitionDelay = "0s";
  content5.style.transitionDelay = "0s";
  content6.style.transitionDelay = "0s";
  content7.style.transitionDelay = "0s";
}

function open3(){
  content1.style.transform = "translateX(1500%)";
  content2.style.transform = "translateX(2500%)";
  content3.style.transform = "translateX(0)";
  content4.style.transform = "translateX(900%)";
  content5.style.transform = "translateX(1500%)";
  content6.style.transform = "translateX(1500%)";
  content7.style.transform = "translateX(900%)";

  btn3.style.color = "#ff7846"
  btn2.style.color = "#ccc"
  btn1.style.color = "#ccc"
  btn4.style.color = "#ccc"
  btn5.style.color = "#ccc"
  btn6.style.color = "#ccc"
  btn7.style.color = "#ccc"

  content3.style.transitionDelay = "0.3s";
  content2.style.transitionDelay = "0s";
  content1.style.transitionDelay = "0s";
  content4.style.transitionDelay = "0s";
  content5.style.transitionDelay = "0s";
  content6.style.transitionDelay = "0s";
  content7.style.transitionDelay = "0s";
}

function open4(){
  content1.style.transform = "translateX(1500%)";
  content2.style.transform = "translateX(2500%)";
  content3.style.transform = "translateX(900%)";
  content4.style.transform = "translateX(0)";
  content5.style.transform = "translateX(1500%)";
  content6.style.transform = "translateX(1500%)";
  content7.style.transform = "translateX(900%)";

  btn4.style.color = "#ff7846"
  btn2.style.color = "#ccc"
  btn3.style.color = "#ccc"
  btn1.style.color = "#ccc"
  btn5.style.color = "#ccc"
  btn6.style.color = "#ccc"
  btn7.style.color = "#ccc"

  content4.style.transitionDelay = "0.3s";
  content2.style.transitionDelay = "0s";
  content3.style.transitionDelay = "0s";
  content1.style.transitionDelay = "0s";
  content5.style.transitionDelay = "0s";
  content6.style.transitionDelay = "0s";
  content7.style.transitionDelay = "0s";
}

function open5(){
  content1.style.transform = "translateX(1500%)";
  content2.style.transform = "translateX(2500%)";
  content3.style.transform = "translateX(900%)";
  content4.style.transform = "translateX(900%)";
  content5.style.transform = "translateX(0)";
  content6.style.transform = "translateX(1500%)";
  content7.style.transform = "translateX(900%)";

  btn5.style.color = "#ff7846"
  btn2.style.color = "#ccc"
  btn3.style.color = "#ccc"
  btn4.style.color = "#ccc"
  btn1.style.color = "#ccc"
  btn6.style.color = "#ccc"
  btn7.style.color = "#ccc"

  content5.style.transitionDelay = "0.3s";
  content2.style.transitionDelay = "0s";
  content3.style.transitionDelay = "0s";
  content4.style.transitionDelay = "0s";
  content1.style.transitionDelay = "0s";
  content6.style.transitionDelay = "0s";
  content7.style.transitionDelay = "0s";
}

function open6(){
  content1.style.transform = "translateX(1500%)";
  content2.style.transform = "translateX(2500%)";
  content3.style.transform = "translateX(900%)";
  content4.style.transform = "translateX(900%)";
  content5.style.transform = "translateX(1500%)";
  content6.style.transform = "translateX(0)";
  content7.style.transform = "translateX(900%)";

  btn6.style.color = "#ff7846"
  btn2.style.color = "#ccc"
  btn3.style.color = "#ccc"
  btn4.style.color = "#ccc"
  btn5.style.color = "#ccc"
  btn1.style.color = "#ccc"
  btn7.style.color = "#ccc"

  content6.style.transitionDelay = "0.3s";
  content2.style.transitionDelay = "0s";
  content3.style.transitionDelay = "0s";
  content4.style.transitionDelay = "0s";
  content5.style.transitionDelay = "0s";
  content1.style.transitionDelay = "0s";
  content7.style.transitionDelay = "0s";
}

function open7(){
  content1.style.transform = "translateX(1500%)";
  content2.style.transform = "translateX(2500%)";
  content3.style.transform = "translateX(900%)";
  content4.style.transform = "translateX(900%)";
  content5.style.transform = "translateX(1500%)";
  content6.style.transform = "translateX(1500%)";
  content7.style.transform = "translateX(0)";

  btn7.style.color = "#ff7846"
  btn2.style.color = "#ccc"
  btn3.style.color = "#ccc"
  btn4.style.color = "#ccc"
  btn5.style.color = "#ccc"
  btn6.style.color = "#ccc"
  btn1.style.color = "#ccc"

  content7.style.transitionDelay = "0.3s";
  content2.style.transitionDelay = "0s";
  content3.style.transitionDelay = "0s";
  content4.style.transitionDelay = "0s";
  content5.style.transitionDelay = "0s";
  content6.style.transitionDelay = "0s";
  content1.style.transitionDelay = "0s";
}




// personal Projects
var pages = document.getElementsByClassName('page');
for(var i = 0; i < pages.length; i++)
  {
    var page = pages[i];
    if (i % 2 === 0)
      {
        page.style.zIndex = (pages.length - i);
      }
  }

document.addEventListener('DOMContentLoaded', function(){
  for(var i = 0; i < pages.length; i++)
    {
      pages[i].pageNum = i + 1;
      pages[i].onclick=function()
        {
          if (this.pageNum % 2 === 0)
            {
              this.classList.remove('flipped');
              this.previousElementSibling.classList.remove('flipped');
            }
          else
            {
              this.classList.add('flipped');
              this.nextElementSibling.classList.add('flipped');
            }
         }
      }
})




// Falling intro
window.onload = () => {
  const para = document.getElementById('me');
  const words = para.textContent.trim().split(' ');
  para.textContent = '';

  let delayCounter = 0;

  words.forEach(word => {
    const wordWrapper = document.createElement('span');
    wordWrapper.classList.add('word');

    for (let i = 0; i < word.length; i++) {
      const charSpan = document.createElement('span');
      charSpan.textContent = word[i];
      charSpan.style.animationDelay = (delayCounter * 0.04) + 's';
      delayCounter++;
      wordWrapper.appendChild(charSpan);
    }

    para.appendChild(wordWrapper);
    para.appendChild(document.createTextNode(' ')); // space between words
    delayCounter++; // slight gap after each word
  });
};




// Languages
const dropbtn = document.querySelector('.languages-dropbtn');
const dropdownContent = document.querySelector('.languages-dropdown-content');

dropbtn.addEventListener('click', (e) => {
  e.stopPropagation(); 
  dropdownContent.classList.toggle('show');
});

window.addEventListener('click', () => {
  if (!dropdownContent.matches(':hover')) {
    dropdownContent.classList.remove('show');
  }
});




// System 
const systemsDropbtn = document.querySelector('.systems-dropbtn');
const systemsDropdownContent = document.querySelector('.systems-dropdown-content');

systemsDropbtn.addEventListener('click', (e) => {
  e.stopPropagation();
  systemsDropdownContent.classList.toggle('show');
});

window.addEventListener('click', () => {
  if (!systemsDropdownContent.matches(':hover')) {
    systemsDropdownContent.classList.remove('show');
  }
});




// Programming language
const programmingDropbtn = document.querySelector('.programming-dropbtn');
const programmingDropdownContent = document.querySelector('.programming-dropdown-content');

programmingDropbtn.addEventListener('click', (e) => {
  e.stopPropagation();
  programmingDropdownContent.classList.toggle('show');
});

window.addEventListener('click', () => {
  if (!programmingDropdownContent.matches(':hover')) {
    programmingDropdownContent.classList.remove('show');
  }
});




// Framework
const frameworksDropbtn = document.querySelector('.frameworks-dropbtn');
const frameworksDropdownContent = document.querySelector('.frameworks-dropdown-content');

frameworksDropbtn.addEventListener('click', (e) => {
  e.stopPropagation();
  frameworksDropdownContent.classList.toggle('show');
});

window.addEventListener('click', () => {
  if (!frameworksDropdownContent.matches(':hover')) {
    frameworksDropdownContent.classList.remove('show');
  }
});




// Cert and other 
function setupDropdown(dropbtnSelector, dropdownContentSelector) {
  const btn = document.querySelector(dropbtnSelector);
  const content = document.querySelector(dropdownContentSelector);

  btn.addEventListener('click', e => {
    e.stopPropagation();
    content.classList.toggle('show');
  });

  window.addEventListener('click', () => {
    if (!content.matches(':hover')) {
      content.classList.remove('show');
    }
  });
}

setupDropdown('.certifications-dropbtn', '.certifications-dropdown-content');
setupDropdown('.others-dropbtn', '.others-dropdown-content');

document.querySelectorAll('.tree-list li > .label').forEach(label => {
    label.addEventListener('click', e => {
      const li = label.parentElement;
      if(li.classList.contains('leaf')) return; // no toggling for leaf
      li.classList.toggle('collapsed');
    });
  });




// Tree
window.addEventListener("DOMContentLoaded", () => {
    const t = new Tree("canvas");
});

class Tree {
    constructor(qs) {
        this.C = document.querySelector(qs);
        this.c = this.C?.getContext("2d");
        this.S = window.devicePixelRatio;
        this.W = 1200;
        this.H = 800;
        this.branches = [];
        this.darkTheme = false;
        this.debug = false;
        this.floorY = 720;
        this.fruit = [];
        this.redFruits = [];
        this.redFruitPositions = [];
        this.gravity = 0.098;
        this.loopDelay = 500;
        this.loopEnd = Utils.dateValue;
        this.maxGenerations = 10;

        this.fruitState = "growing";
        this.fruitWaitTimer = 0;
        this.maxFruitCount = 150;

        this.mouseX = 0;
        this.mouseY = 0;
        this.hoveredFruitIndices = new Set();

        if (this.C) this.init();
    }

    get allBranchesComplete() {
        const { branches, maxGenerations } = this;
        return branches.filter(b => {
            const isLastGen = b.generation === maxGenerations;
            return b.progress >= 1 && isLastGen;
        }).length > 0;
    }

    get allFruitComplete() {
        return !!this.fruit.length && this.fruit.every(f => f.progress === 1);
    }

    get allFruitFallen() {
        return !!this.fruit.length && this.fruit.every(f => f.decayTime <= 0);
    }

    get debugInfo() {
        return [
            { item: 'Pixel Ratio', value: this.S },
            { item: 'Branches', value: this.branches.length },
            { item: 'Branches Complete', value: this.allBranchesComplete },
            { item: 'Fruit', value: this.fruit.length },
            { item: 'Fruit Complete', value: this.allFruitComplete },
            { item: 'Fruit State', value: this.fruitState }
        ];
    }

    get lastGeneration() {
        const genIntegers = this.branches.map(b => b.generation);
        return [...new Set(genIntegers)].pop();
    }

    get trunk() {
        return {
            angle: 0,
            angleInc: 20,
            decaySpeed: 0.0625,
            diameter: 11.5,
            distance: 162,
            distanceFade: 0.2,
            generation: 1,
            growthSpeed: 0.004,
            hadBranches: false,
            progress: 0,
            x1: this.W / 2,
            y1: 710,
            x2: this.W / 2,
            y2: 600
        };
    }

    detectTheme(mq) {
        this.darkTheme = mq.matches;
    }

    draw() {
        const { c, W, H, debug, branches, fruit } = this;

        c.clearRect(0, 0, W, H);

        // Ground shadow
        c.save();
        c.fillStyle = this.darkTheme ? "rgba(0, 0, 0, 0.5)" : "rgba(0, 0, 0, 0.25)";
        c.filter = "blur(10px)";
        c.beginPath();
        c.ellipse(this.W / 2, this.floorY + 15, 500, 120, 0, 0, 2 * Math.PI);
        c.fill();
        c.restore();

        // Draw all branches with gradient along their current growth
        branches.forEach(b => {
            const endX = b.x1 + (b.x2 - b.x1) * b.progress;
            const endY = b.y1 + (b.y2 - b.y1) * b.progress;

            const gradient = c.createLinearGradient(b.x1, b.y1, endX, endY);
            gradient.addColorStop(0, "#ffffffff");
            gradient.addColorStop(1, "#86d0d0ff");

            c.strokeStyle = gradient;
            c.lineWidth = b.diameter;
            c.beginPath();
            c.moveTo(b.x1, b.y1);
            c.lineTo(endX, endY);
            c.stroke();
        });

        // Optional debug info
        if (debug) {
            const textX = 24;
            this.debugInfo.forEach((d, i) => {
                c.fillText(`${d.item}: ${d.value}`, textX, 24 * (i + 1));
            });
        }

        // Draw fruit
        fruit.forEach((f, i) => {
            c.globalAlpha = 1;
            const isFalling = (!f.isRed) && (f.forcedFall || (this.fruitState === "falling" && f.timeUntilFall <= 0));
            let swayX = 0;
            const now = performance.now();
            if (this.hoveredFruitIndices.has(i) && !isFalling) {
                swayX = 3 * Math.sin(now * 0.005 + i);
            }

            const fruitX = isFalling ? f.x : f.branchX + swayX;
            const fruitY = isFalling ? f.y : f.branchY + f.r * f.progress;

            const gradient = c.createRadialGradient(fruitX, fruitY, f.r * 0.1, fruitX, fruitY, f.r);
            if (f.isRed) {
                gradient.addColorStop(0, '#ff4d4d');
                gradient.addColorStop(1, '#800000');
            } else {
                gradient.addColorStop(0, '#b0d668ff');
                gradient.addColorStop(1, '#3a6b0a');
            }
            c.fillStyle = gradient;
            c.beginPath();
            c.arc(fruitX, fruitY, f.r * f.progress, 0, 2 * Math.PI);
            c.fill();

            const highlightX = fruitX - f.r * 0.3;
            const highlightY = fruitY - f.r * 0.3;
            const highlightGradient = c.createRadialGradient(highlightX, highlightY, 0, highlightX, highlightY, f.r * 0.3);
            highlightGradient.addColorStop(0, 'rgba(255,255,255,0.7)');
            highlightGradient.addColorStop(1, 'rgba(255,255,255,0)');
            c.fillStyle = highlightGradient;
            c.beginPath();
            c.arc(highlightX, highlightY, f.r * 0.3, 0, 2 * Math.PI);
            c.fill();

            const stemHeight = f.r * 0.4 * f.progress;
            const stemWidth = f.r * 0.1 * f.progress;
            c.fillStyle = '#4b2e05';
            c.beginPath();
            c.moveTo(f.branchX + swayX, f.branchY);
            c.lineTo(f.branchX - stemWidth + swayX, f.branchY - stemHeight);
            c.lineTo(f.branchX + stemWidth + swayX, f.branchY - stemHeight);
            c.closePath();
            c.fill();
        });
    }

    shuffleArray(array) {
        for (let i = array.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [array[i], array[j]] = [array[j], array[i]];
        }
        return array;
    }

    setupRandomFruit() {
        const lastGenBranches = this.branches.filter(b => b.generation === this.maxGenerations);
        const shuffledBranches = this.shuffleArray(lastGenBranches);
        const redFruitPositions = [];
        const redFruits = [];

        for (const branch of shuffledBranches) {
            if (redFruitPositions.length >= 5) break;
            let tooClose = false;
            for (const pos of redFruitPositions) {
                if (Math.hypot(branch.x2 - pos.x, branch.y2 - pos.y) < 40) {
                    tooClose = true;
                    break;
                }
            }
            if (!tooClose) {
                redFruitPositions.push({ x: branch.x2, y: branch.y2 });
                redFruits.push({
                    branchX: branch.x2,
                    branchY: branch.y2,
                    decayFrames: 18,
                    decayTime: 150,
                    progress: 0,
                    speed: 0.04,
                    timeUntilFall: 0,
                    x: branch.x2,
                    y: branch.y2,
                    r: Utils.randomInt(12, 14),
                    restitution: 0.2 * (1 - branch.y2 / this.floorY),
                    yVelocity: 0,
                    isRed: true
                });
            }
        }

        this.redFruitPositions = redFruitPositions;
        this.redFruits = redFruits;
        const greenFruits = this.setupGreenFruits(redFruitPositions, redFruits.length);
        this.fruit = [...redFruits, ...greenFruits];
    }

    setupGreenFruits(redFruitPositions, existingFruitCount) {
        const lastGenBranches = this.branches.filter(b => b.generation === this.maxGenerations);
        const shuffledBranches = this.shuffleArray(lastGenBranches);
        const greenFruits = [];

        for (const branch of shuffledBranches) {
            if ((existingFruitCount + greenFruits.length) >= this.maxFruitCount) break;
            let tooClose = false;
            for (const pos of redFruitPositions) {
                if (Math.hypot(branch.x2 - pos.x, branch.y2 - pos.y) < 20) {
                    tooClose = true;
                    break;
                }
            }
            if (!tooClose) {
                greenFruits.push({
                    branchX: branch.x2,
                    branchY: branch.y2,
                    decayFrames: 18,
                    decayTime: 150,
                    progress: 0,
                    speed: 0.04,
                    timeUntilFall: 0,
                    x: branch.x2,
                    y: branch.y2,
                    r: Utils.randomInt(8, 12),
                    restitution: 0.2 * (1 - branch.y2 / this.floorY),
                    yVelocity: 0,
                    isRed: false
                });
            }
        }
        return greenFruits;
    }

    grow() {
        if (!this.branches.length && Utils.dateValue - this.loopEnd > this.loopDelay) {
            this.branches.push(this.trunk);
        }

        if (!this.allBranchesComplete) {
            this.branches.forEach(b => {
                if (b.progress < 1) {
                    b.progress += b.growthSpeed;
                    if (b.progress > 1) b.progress = 1;
                } else if (!b.hadBranches && b.generation < this.maxGenerations) {
                    b.hadBranches = true;

                    const angleLeft = b.angle - b.angleInc;
                    const angleRight = b.angle + b.angleInc;
                    const distance = b.distance * (1 - b.distanceFade) * 1.02;
                    const generation = b.generation + 1;

                    const leftBranch = {
                        angle: angleLeft,
                        angleInc: b.angleInc,
                        decaySpeed: b.decaySpeed,
                        diameter: Math.floor(b.diameter * 0.9),
                        distance,
                        distanceFade: b.distanceFade,
                        generation,
                        growthSpeed: b.growthSpeed,
                        hadBranches: false,
                        progress: 0,
                        x1: b.x2,
                        y1: b.y2,
                        x2: b.x2 + Utils.endPointX(angleLeft, distance),
                        y2: b.y2 - Utils.endPointY(angleLeft, distance)
                    };

                    const rightBranch = { ...leftBranch };
                    rightBranch.angle = angleRight;
                    rightBranch.x2 = b.x2 + Utils.endPointX(angleRight, distance);
                    rightBranch.y2 = b.y2 - Utils.endPointY(angleRight, distance);

                    this.branches.push(leftBranch, rightBranch);
                }
            });
        } else {
            if (this.fruit.length === 0) this.setupRandomFruit();

            if (this.fruitState === "growing") {
                this.fruit.forEach(f => {
                    if (f.progress < 1) {
                        f.progress += f.speed;
                        if (f.progress > 1) f.progress = 1;
                    }
                });
                if (this.allFruitComplete) {
                    this.fruitState = "waiting";
                    this.fruitWaitTimer = 5000;
                }
            }
        }
    }

    decay(deltaTime) {
        this.fruit.forEach(f => {
            if (!f.isRed && f.forcedFall) {
                f.y += f.yVelocity;
                f.yVelocity += this.gravity;
                const bottom = this.floorY - f.r;
                if (f.y >= bottom) {
                    f.y = bottom;
                    f.yVelocity *= -f.restitution;
                }
                if (f.decayTime > 0) --f.decayTime;
            }
        });

        if (this.fruitState === "waiting") {
            this.fruitWaitTimer -= deltaTime;
            if (this.fruitWaitTimer <= 0) {
                this.fruitState = "falling";
                this.fruit.forEach(f => {
                    if (!f.isRed) {
                        const batchIndex = Math.floor(Math.random() * 20);
                        f.timeUntilFall = batchIndex * 500;
                        f.yVelocity = 0;
                        f.decayTime = 150;
                    } else {
                        f.timeUntilFall = Infinity;
                    }
                });
            }
        }

        if (this.fruitState === "falling") {
            let allFallen = true;
            this.fruit.forEach(f => {
                if (f.isRed || f.forcedFall) return;
                if (f.timeUntilFall <= 0) {
                    f.y += f.yVelocity;
                    f.yVelocity += this.gravity;
                    const bottom = this.floorY - f.r;
                    if (f.y >= bottom) {
                        f.y = bottom;
                        f.yVelocity *= -f.restitution;
                    }
                    --f.decayTime;
                    if (f.decayTime > 0) allFallen = false;
                } else {
                    --f.timeUntilFall;
                    allFallen = false;
                }
            });

            if (allFallen) {
                const greenFruits = this.setupGreenFruits(this.redFruitPositions, this.redFruits.length);
                this.fruit = [...this.redFruits, ...greenFruits];
                this.fruitState = "growing";
            }
        }
    }

    init() {
        this.setupCanvas();
        this.setupThemeDetection();
        this.lastTime = performance.now();

        // Hover detection (only for sway effect, no popup)
        this.C.addEventListener("mousemove", (e) => {
            const rect = this.C.getBoundingClientRect();
            this.mouseX = (e.clientX - rect.left) * (this.C.width / rect.width) / this.S;
            this.mouseY = (e.clientY - rect.top) * (this.C.height / rect.height) / this.S;
            this.hoveredFruitIndices.clear();

            this.fruit.forEach((f, i) => {
                const isFalling = (!f.isRed) && (f.forcedFall || (this.fruitState === "falling" && f.timeUntilFall <= 0));
                const fruitCenterX = isFalling ? f.x : f.branchX;
                const fruitCenterY = isFalling ? f.y : f.branchY + f.r * f.progress;

                if (Math.hypot(this.mouseX - fruitCenterX, this.mouseY - fruitCenterY) <= f.r * f.progress) {
                    this.hoveredFruitIndices.add(i);
                }
            });
        });

        this.C.addEventListener("mouseleave", () => {
            this.hoveredFruitIndices.clear();
        });

        // Click-to-drop green apple or show red apple popup
// Click-to-drop green apple or show red apple popup
this.C.addEventListener("click", (e) => {
    this.hoveredFruitIndices.forEach(i => {
        const f = this.fruit[i];

        if (f.isRed) {
            const popup = document.getElementById(`apple-${i + 1}`);
            if (popup) {
                // Close any other open popups
                document.querySelectorAll(".apple-popup.show")
                    .forEach(p => { if (p !== popup) p.classList.remove("show"); });

                // Show this popup
                popup.classList.add("show");

                // Close when mouse leaves the popup, with hover protection
                if (!popup._hoverBound) {
                    let closeTimeout;

                    popup.addEventListener("pointerleave", () => {
                        closeTimeout = setTimeout(() => {
                            popup.classList.remove("show");
                        }, 50); // short delay
                    });

                    popup.addEventListener("pointerenter", () => {
                        clearTimeout(closeTimeout);
                    });

                    popup._hoverBound = true;
                }

                // Prevent click propagation to canvas
                e.stopPropagation();
            }
        } else {
            // Green fruit: make it fall
            if (!f.forcedFall) {
                f.forcedFall = true;
                f.x = f.branchX;
                f.y = f.branchY + f.r * f.progress;
                f.yVelocity = 0;
                f.decayTime = 150;
            }
        }
    });
});

// Attach ONCE: close popup if click outside
if (!this._outsideBound) {
    this._outsideBound = true;
    document.addEventListener("click", (ev) => {
        if (!ev.target.closest(".apple-popup")) {
            document.querySelectorAll(".apple-popup.show")
                .forEach(p => p.classList.remove("show"));
        }
    });
}


        this.run();
    }

    run() {
        const now = performance.now();
        const deltaTime = now - this.lastTime;
        this.lastTime = now;
        this.draw();
        this.grow();
        if (this.allBranchesComplete) this.decay(deltaTime);
        requestAnimationFrame(this.run.bind(this));
    }

    setupCanvas() {
        const { C, c, W, H, S } = this;
        C.width = W * S;
        C.height = H * S;
        C.style.width = "auto";
        C.style.height = "100%";
        c.scale(S, S);
        c.font = "16px sans-serif";
        c.lineCap = "round";
        c.lineJoin = "round";
    }

    setupThemeDetection() {
        if (window.matchMedia) {
            const mq = window.matchMedia("(prefers-color-scheme: dark)");
            this.detectTheme(mq);
            mq.addListener(this.detectTheme.bind(this));
        }
    }
}

class Utils {
    static get dateValue() { return +new Date(); }
    static endPointX(angleInDeg, distance) { return Math.sin(angleInDeg * Math.PI / 180) * distance; }
    static endPointY(angleInDeg, distance) { return Math.cos(angleInDeg * Math.PI / 180) * distance; }
    static randomInt(min, max) { return min + Math.round(Math.random() * (max - min)); }
}


